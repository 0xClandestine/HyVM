#include "debug-utils.huff"

// will store the reentrency slot in a random storage slot
#define constant CALL_VERIFIER_SSLOT = 0x58a8a9223af434080477cd2d1a2667aba3ce9f1301007611a4d07a0af708e65a


// used to store the result of call checking (1 word)
#define constant CALLRESULT_MSLOT = 0x20


// used to store call checking arguments
// CHECK_CALL() will pass args:
//  - function selector (0x04 length... signature of "verifyCall(uint1,address,uint256,bytes,bool)")
//  - opcode (0x20 length packed)
//  - contract address (0x20 length packed)
//  - value sent (0x20 length packed)
//  - copy of the first 10 words of calldata:
//      * pointer to data (len 0x20)
//      * array len (len 0x20)
//      * actual data (len 0x140)
//  - isTruncated (0x20 length packed)
// sum = 4 + 0x20 x 6 + 0x140 = 0x204 length , starting at 0x40
#define constant CALLARGS_MSLOT = 0x40
// details:
#define constant CALLARGS_MAX_DATALEN = 0x140
#define constant CALLARGS_TOTALLEN = 0x204

#define constant CALLARGS_MSLOT_selector = 0x40
#define constant CALLARGS_MSLOT_opcode = 0x44
#define constant CALLARGS_MSLOT_opcode = 0x44
#define constant CALLARGS_MSLOT_contract = 0x64 // +0x20
#define constant CALLARGS_MSLOT_value = 0x84 // +0x20
#define constant CALLARGS_MSLOT_calldata = 0xA4 // +0x20
#define constant CALLARGS_MSLOT_isTruncated = 0xC4 // +0x20
#define constant CALLARGS_MSLOT_calldata_len = 0xE4 // +0x20
#define constant CALLARGS_MSLOT_calldata_raw = 0x104 // +0x20

// jump table will be located at 0x20, after the execution pointer
#define constant OPCODES_JUMPTABLE_MSLOT = 0x260 // 0x40 + 0x204, rounded to upper 20  (= CALLARGS_MSLOT + CALLARGS_TOTALLEN = CALLARGS_MSLOT_calldata_raw + CALLARGS_MAX_DATALEN)



#define macro CHECK_DELEGATECALL() = takes(0) returns (0) {
        // - check can call
        dup4 // push argSize => [argSize, gas address argsOffset argsSize retOffset retSize]
        dup4 // push argOffset => [argOffset, argSize, gas address argsOffset argsSize retOffset retSize]
        0x0  // push value => [value, argSize, gas address argsOffset argsSize retOffset retSize]
        dup5 // push contract address => [contact, argSize, gas address argsOffset argsSize retOffset retSize]
        0xFA // push opcode => [opcode, argSize, gas address argsOffset argsSize retOffset retSize]
        CHECK_GENERIC_CALL()
}

#define macro CHECK_STATICCALL() = takes(0) returns (0) {

        // - check can call
        dup4 // push argSize => [argSize, gas address argsOffset argsSize retOffset retSize]
        dup4 // push argOffset => [argOffset, argSize, gas address argsOffset argsSize retOffset retSize]
        0x0  // push value => [value, argSize, gas address argsOffset argsSize retOffset retSize]
        dup5 // push contract address => [contact, argSize, gas address argsOffset argsSize retOffset retSize]
        0xFA // push opcode => [opcode, argSize, gas address argsOffset argsSize retOffset retSize]

        CHECK_GENERIC_CALL() // => [gas address argsOffset argsSize retOffset retSize]
}

#define macro CHECK_CALLCODE() = takes(0) returns (0) {
        // - check can call
        dup5 // push argSize
        dup5 // push argOffset
        dup5 // push value
        dup5 // push contract address
        0xF4 // push opcode
        CHECK_GENERIC_CALL()
}

#define macro CHECK_CALL() = takes(0) returns (0) {
        // - check can call
        dup5 // push argSize
        dup5 // push argOffset
        dup5 // push value
        dup5 // push contract address
        0xF1 // push opcode
        CHECK_GENERIC_CALL()
}



#define macro CHECK_VERIFIER() = takes(1) returns (1) {
    dup1 verifier_ok jumpi

    // console.log('no call verifier set')
    0x6e6f2063616c6c20766572696669657220736574000000000000000000000000
    0x0000000000000000000000000000000000000000000000000000000000000014
    CONSOLE_LOG()

    0x00 0x00 revert

    verifier_ok:
}

/**
Checks that a call can be performed
 -> taking stack [callOpcode, callContract, sentValue, argOffset, argSize]
*/
#define macro CHECK_GENERIC_CALL() = takes(4) returns (0) {


    //  ==========> /!\ WARNING: do not use CONSOLE_LOG() in this macro  /!\ <=========
    //  because it writes to CALLARGS_MSLOT (avoids allocating debug memory)

    //  =>  read the doc of CALLARGS_MSLOT constant to understand the memory layout written here.

    // copy opcode to args
    [CALLARGS_MSLOT_opcode] mstore // => [callContract, sentValue, argOffset, argSize]
    // copy contract to args
    [CALLARGS_MSLOT_contract] mstore // => [sentValue, argOffset, argSize]
    // copy sent value to args
    [CALLARGS_MSLOT_value] mstore // => [argOffset, argSize]


    // store "isTrucated" as false
    0x0 [CALLARGS_MSLOT_isTruncated] mstore


    // -> here, we have [argOffset, argSize] on stack
    swap1 // => [argSize, argOffset]

    //  == check that is not greater than max, else push max

    dup1 [CALLARGS_MAX_DATALEN] lt  // [calldata.length > CALLARGS_MAX_DATALEN, argSize, argOffset]
    iszero
    callargs_not_maxed jumpi

    // if (caldata.length > CALLARGS_MAX_DATALEN) {

        // store "isTrucated" as true
        0x1 [CALLARGS_MSLOT_isTruncated] mstore

        // pop length, and push max args instead
        pop
        [CALLARGS_MAX_DATALEN]

    // }


    callargs_not_maxed:
    // -> we now have on stack [argSize, argOffset]


    // write signature of verifyCall(uint1,address,uint256,bytes,bool) to selector
    0x1c8eb044 0xE0 shl [CALLARGS_MSLOT_selector] mstore

    // write a data pointer to args data
    0xa0 [CALLARGS_MSLOT_calldata] mstore

    // write data length
    dup1 [CALLARGS_MSLOT_calldata_len] mstore

    // copy calldata
    [CALLARGS_MSLOT_calldata_raw] // => [target, argSize, argOffset]
    swap2 // => [argOffset, argSize, target]
    swap1 // => [argSize, argOffset, target]

    MEM_COPY() //  => []


    // call verifier smartcontract
    0x20 // retSize
    [CALLRESULT_MSLOT] // retOffset
    [CALLARGS_TOTALLEN] // argSize (we're giving it all, since we trust this contract... save a bit of code)
    [CALLARGS_MSLOT] // argOffset
    [CALL_VERIFIER_SSLOT] sload // contract to call
    CHECK_VERIFIER()
    gas
    staticcall // => [success]

    // load result
    [CALLRESULT_MSLOT] mload // => [ok, success]

    // check that the call succeeded
    and checkcall_success jumpi // => []

    //  => verification failed !
    // console.log('failed to verify call')
    0x6661696c656420746f207665726966792063616c6c0000000000000000000000
    0x0000000000000000000000000000000000000000000000000000000000000015
    CONSOLE_LOG()

    0x00 0x00 revert

    checkcall_success:
}


// check that the pending SSTORE operation is OK
#define macro CHECK_SSTORE() = takes(0) returns (0) {
    // here, the first value on stack is the key to store

    dup1 [REENTRANT_SSLOT] sload eq
    dup1 [CALL_VERIFIER_SSLOT] sload eq
        or
    dup1 [OWNER_SSLOT] sload eq
        or

    // jump to success if those slots are not protected
    iszero checksstore_success jumpi

    // check that we're owner (if we are, then we can proceed)
    ONLY_OWNER()

    checksstore_success:
}
